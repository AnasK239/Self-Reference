To be honest its probably black magic, in its essence its just shape shifting

Best explained with an example:

Assume an abstract class called Vehicle .. Define 3 types of Vehicles ( car ,boat ,bike) they all extend Vehicle class

Now if we want to group up the 3 types in an array what should the type be ? well it should be something that all the classes have in common

any Car object identifies as Car but also identifies as a vehicle  same goes for others.

so we group them up in an array with type of common trait >> Vehicle[] <name> = {car,bike,boat};

This works because all the classes identify as Vehicle


### This can be achieved by an abstract class or an interface whichever you prefer.


####################### RUNTIME POLYMORPHISIM ########################

The method excuted is morphed during runtime based on user input best explained with an example :

### assume an abstract class Animal  which has two children either a dog or a cat , suppose this is an animal rescue shelter

the user will have to choose wether they take a cat home or a dog or both :)

if the cat is picked it says MEOW  ,, if the dog is picked it says woof 

so we will need to morph the object to the user's liking the code below shows a rough outline:

public class Main {
    public static void main(String[] args) {

    Scanner scanner = new Scanner(System.in);
     Animal animal;						// an abstract animal with many possibilites (2 in this case)

    System.out.println("Would you like a cat or a dog? (1. Dog ,, 2. Cat)");
    int ans = scanner.nextInt();

    if(ans == 1)
    {
        animal = new Dog();
        animal.speak();
    }
    else if (ans ==2)                        ## speak is an Animal defined method
    {
        animal = new Cat();
        animal.speak();
    }
    scanner.close();
    }
